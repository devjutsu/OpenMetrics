@page "/"
@using Blazored.Toast.Services
@using MetaMask.Blazor
@using MetaMask.Blazor.Enums
@using OpenMetrics.Components
@using OpenMetrics.Services
@inject MetaMaskService Meta
@inject AppState AppState
@inject ClientConfig CFG
@inject IToastService Toast
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Index</PageTitle>

@if (@Spinning)
{
    <Spinner />
}

@if (!AppState.IsAuthenticated)
{
    <div>
        <div class="d-flex justify-content-center">
            <button class="btn btn-primary" @onclick="(() => Authenticate())" disabled="@(!HasMetaMask)">
                Authenticate
            </button>
        </div>

        @if (!HasMetaMask)
        {
            <div class="d-flex justify-content-center vertical-space darktext">
                Please authenticate with <span>&nbsp;</span> <a href="https://metamask.io" target="_blank"> MetaMask </a>.
            </div>
        }
    </div>
}
else if (!ProperChain)
{
    <div>Please, select <span style="color: #5a349aff; font-weight:bold">@NeededChain</span> chain</div>
    <button class="btn btn-primary" @onclick="@(() => SwitchChain())">Open MetaMask</button>
}
else
{
    <div>ok</div>
}

@code {
    bool Spinning = false;
    bool HasMetaMask = false;
    bool ProperChain => AppState.ChainId == CFG.NetworkId;
    string NeededChain => NetworksList.Networks[CFG.NetworkId];

    protected override async Task OnInitializedAsync()
    {
        HasMetaMask = await Meta.HasMetaMask();
        if (HasMetaMask)
            await Meta.ListenToEvents();

        bool isSiteConnected = await Meta.IsSiteConnected();
        if (isSiteConnected)
        {
            await GetSelectedNetwork();
        }

        MetaMaskService.AccountChangedEvent += MetaMaskService_AccountChangedEvent;
        MetaMaskService.ChainChangedEvent += MetaMaskService_ChainChangedEvent;
    }

    private async Task MetaMaskService_ChainChangedEvent((long, Chain) arg)
    {
        await GetSelectedNetwork();
    }

    private async Task MetaMaskService_AccountChangedEvent(string arg)
    {
        await Authenticate();
    }

    async Task Authenticate()
    {
        Console.WriteLine("Authenticating...");
        Spinning = true;
        if (!await Meta.HasMetaMask())
        {
            Console.WriteLine("Has no MetaMask");
            HasMetaMask = await Meta.HasMetaMask();
            StateHasChanged();
        }
        else
        {
            try
            {
                if (!await Meta.IsSiteConnected())
                    await Meta.ConnectMetaMask();
                var userId = await Meta.GetSelectedAddress();
                await GetSelectedNetwork();
                HasMetaMask = true;
                await AppState.Login(this, userId);
            }
            catch (Exception ex)
            {
                Toast.ShowError($"Auth failed. Please, check your wallet");
            }
        }
        Spinning = false;
    }

    public async Task GetSelectedNetwork()
    {
        Spinning = true;
        var chainInfo = await Meta.GetSelectedChain();

        AppState.SetChain(this, chainInfo.chainId);
        Console.WriteLine($"ChainID: {AppState.ChainId}");

        if (ProperChain)
        {
            Console.WriteLine($"Authenticated on: {NetworksList.Networks[AppState.ChainId]}");
        }
        else
        {
            Toast.ShowWarning($"Please, connect to chain: {NetworksList.Networks[CFG.NetworkId]}");
        }
        Spinning = false;
        StateHasChanged();
    }

    async Task SwitchChain()
    {
        var toChain = "0x" + CFG.NetworkId.ToString("X");
        await JS.InvokeVoidAsync("switchChain", toChain);
    }

    // ----
    protected override void OnInitialized()
    {
        AppState.Statechanged += async (Source, Property) => await AppState_StateChanged(Source, Property);
    }

    private async Task AppState_StateChanged(ComponentBase source, string Property)
    {
        if (source != this) await InvokeAsync(StateHasChanged);
    }

    void IDisposable.Dispose()
    {
        AppState.Statechanged -= async (Source, Property) => await AppState_StateChanged(Source, Property);
    }
}
