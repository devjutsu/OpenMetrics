@page "/"
@using Blazored.Toast.Services
@using MetaMask.Blazor
@using MetaMask.Blazor.Enums
@using OpenMetrics.Components
@using OpenMetrics.Services
@using OpenMetrics.ViewModels
@inject MetaMaskService Meta
@inject AppState AppState
@inject ClientConfig CFG
@inject IChain Blockchain
@inject IToastService Toast
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Index</PageTitle>

@if (@Spinning)
{
    <Spinner />
}

@if (!AppState.IsAuthenticated)
{
    <div>
        <div class="d-flex justify-content-center">
            <button class="btn btn-primary" @onclick="(() => Authenticate())" disabled="@(!HasMetaMask)">
                Authenticate
            </button>
        </div>

        @if (!HasMetaMask)
        {
            <div class="d-flex justify-content-center vertical-space darktext">
                Please authenticate with <span>&nbsp;</span> <a href="https://metamask.io" target="_blank"> MetaMask </a>.
            </div>
        }
    </div>
}
else if (!ProperChain)
{
    <div>Please, select <span style="color: #5a349aff; font-weight:bold">@NeededChain</span> chain</div>
    <button class="btn btn-primary" @onclick="@(() => SwitchChain())">Open MetaMask</button>
}
else
{
    <div style="margin-top: 1rem; margin-bottom: 1rem;">Metrics: @MetricsCount</div>

    <ListMetricsComponent />

    <div style="margin-top: 1rem; margin-bottom: 1rem;">
        <button class="btn btn-primary" @onclick="@(() => OpenAddMetric())">Add Metric</button>
    </div>

    @if(AddingMetrics)
    {
        <AddMetricComponent DoneAdding=DoneAdding />
    }

    <ListMetricsComponent Metrics=Metrics />
}

@code {
    bool Spinning = false;
    bool HasMetaMask = false;
    bool ProperChain => AppState.ChainId == CFG.NetworkId;
    string NeededChain => NetworksList.Networks[CFG.NetworkId];
    ulong MetricsCount = 0;
    bool AddingMetrics = false;
    List<Metric> Metrics = new List<Metric>();

    protected override async Task OnInitializedAsync()
    {
        HasMetaMask = await Meta.HasMetaMask();
        if (HasMetaMask)
            await Meta.ListenToEvents();

        bool isSiteConnected = await Meta.IsSiteConnected();
        if (isSiteConnected)
        {
            await GetSelectedNetwork();
        }

        MetaMaskService.AccountChangedEvent += MetaMaskService_AccountChangedEvent;
        MetaMaskService.ChainChangedEvent += MetaMaskService_ChainChangedEvent;


        if (!await Meta.IsSiteConnected())
            await Meta.ConnectMetaMask();
        var userId = await Meta.GetSelectedAddress();
        if(!string.IsNullOrEmpty(userId))
        {
            await AppState.Login(this, userId);
        }

        MetricsCount = (ulong)(await Blockchain.MetricsCount());
        if(MetricsCount > 0)
        {
            await GetAllMetrics();
        }
    }

    private async Task MetaMaskService_ChainChangedEvent((long, Chain) arg)
    {
        await GetSelectedNetwork();
    }

    private async Task MetaMaskService_AccountChangedEvent(string arg)
    {
        await Authenticate();
    }

    async Task Authenticate()
    {
        Console.WriteLine("Authenticating...");
        Spinning = true;
        if (!await Meta.HasMetaMask())
        {
            Console.WriteLine("Has no MetaMask");
            HasMetaMask = await Meta.HasMetaMask();
            StateHasChanged();
        }
        else
        {
            try
            {
                if (!await Meta.IsSiteConnected())
                    await Meta.ConnectMetaMask();
                var userId = await Meta.GetSelectedAddress();
                await GetSelectedNetwork();
                HasMetaMask = true;
                await AppState.Login(this, userId);
            }
            catch (Exception ex)
            {
                Toast.ShowError($"Auth failed. Please, check your wallet");
            }
        }
        Spinning = false;
    }

    public async Task GetSelectedNetwork()
    {
        Spinning = true;
        var chainInfo = await Meta.GetSelectedChain();

        AppState.SetChain(this, chainInfo.chainId);
        Console.WriteLine($"Network id: {AppState.ChainId}");

        if (ProperChain)
        {
            Console.WriteLine($"Authenticated on: {NetworksList.Networks[AppState.ChainId]}");
        }
        else
        {
            Toast.ShowWarning($"Please, connect to chain: {NetworksList.Networks[CFG.NetworkId]}");
        }
        Spinning = false;
        StateHasChanged();
    }

    async Task SwitchChain()
    {
        var toChain = "0x" + CFG.NetworkId.ToString("X");
        await JS.InvokeVoidAsync("switchChain", toChain);
    }

    async Task OpenAddMetric()
    {
        AddingMetrics = true;
    }

    async Task DoneAdding(Metric metric)
    {
        Spinning = true;
        try
        {
            var added = await Blockchain.SubmitMetric(metric);
            metric.Id = ++MetricsCount;

            Console.WriteLine($"Added: {added}");
            if(!string.IsNullOrEmpty(added))
            {
                Metrics.Add(metric);
            }
            AddingMetrics = false;
        }
        catch(Exception ex)
        {
            Toast.ShowError($"hz: {ex.Message}");
        }
        Spinning = false;
    }

    async Task GetAllMetrics()
    {
        for(ulong i = 1; i <= MetricsCount; i++)
        {
            var item = await Blockchain.GetMetric(i);
            Metrics.Add(item);
            StateHasChanged();
        }
    }

    // ----
    protected override void OnInitialized()
    {
        AppState.Statechanged += async (Source, Property) => await AppState_StateChanged(Source, Property);
    }

    private async Task AppState_StateChanged(ComponentBase source, string Property)
    {
        if (source != this) await InvokeAsync(StateHasChanged);
    }

    void IDisposable.Dispose()
    {
        AppState.Statechanged -= async (Source, Property) => await AppState_StateChanged(Source, Property);
    }
}
